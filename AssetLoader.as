package com.laz.util{/* * Class AssetLoader * by Lisa Ziegler (lisa.ziegler@gmail.com) * Copyright 2008 */// This class will load one asset or an array of assets.  You can set the assets as mandatory // loads or passive/silent background loads.  If you have a list of mandatory loads in loadArray,// and a list of lazy loads in passiveLoadArray, calling loadAssets after addAssets will start loading assets// and check for lazy loads during the onLoadComplete event. This loader is built as if there will be at least one// asset to be loaded in loadArray, not all passive loads.  If you want all passive loads, call addAssets then// call loadPassive.// There is a boolean called "self" that allows the user to even track the load progress// of the file calling this class.  This is usefull if you want a progress bar when loading a // large app.	import flash.display.*;	import flash.events.*;	import flash.net.URLRequest;	import flash.utils.ByteArray;		import com.laz.util.LoaderDispatcher;		public class AssetLoader extends Sprite	{		private var mc:Object						= new Object();		private var loadArray:Object 				= new Object(); //list of mandatory loads		private var passiveLoadArray:Object			= new Object(); // list of lazy loads; get put in passiveLoadArray		private var totalBytes:Array				= new Array(); // array of total bytes for each asset				private var totalAssets:Number				= 0; // total in the mandatory list		private var totalComplete:Number			= 0; // total number of assets completely loaded		private var totalAudit:Number				= 0; // total that have reported in				public var totalOverAllBytes:Number			= 0; // total number of overall bytes		public var totalOverallBytesLoaded:Number	= 0; // total number of overall bytes loaded						public var loader			:Loader;			public var url				:*;		public var oIndex			:Object;   //1, 2, 3, etc		public var mandatory		:Boolean;  //gets put in loadArray. don't set 'self' to mandatory		public var self				:Boolean;  //this allows the loader to give progress percent											   //on the swf calling this class		public var _fComplete		:Function;		public var _fError			:Function;		public var _fProgress		:Function;		public var progressOutput	:String;				private var loaderState:String			= 'IDLE';		private var dispatcher:LoaderDispatcher = new LoaderDispatcher;		//public static const ASSETLOADER_COMPLETE:String = "assetLoaderComplete";				//item number and callback are cast as objects to allow any data type		public function AssetLoader()		{					}				private function reset():void        {			totalAssets 				= 0;			totalAudit 					= 0;			totalOverAllBytes			= 0;			totalOverallBytesLoaded		= 0;			totalComplete				= 0;        }				//this is the function to call externally. The three functions are optional.		public function addAssets(url:*, 									oIndex:Object, 									mandatory:Boolean, 									self:Boolean = false, 									fComplete:Function = null, 									fProgress:Function = null, 									fError:Function = null)		{			if(self == true)			{				mc = {url:url,mandatory:mandatory,self:self,fComplete:fComplete,fProgress:fProgress,fError:fError};				_fComplete = fComplete;				_fError	   = fError;			    _fProgress = fProgress			}			//adds assets to load arrays. if mandatory is false, then that asset will load 			//after the mandatory ones			else if(mandatory)			{				loadArray[oIndex] = {url:url,fComplete:fComplete,fProgress:fProgress,fError:fError};				_fComplete = fComplete;				_fError	   = fError;			    _fProgress = fProgress			}			else {				passiveLoadArray[oIndex] = {url:url,mandatory:mandatory,self:self,											fComplete:fComplete,											fProgress:fProgress,											fError:fError};			}		}				//call this function after addAssets		public function loadAssets()		{			loaderState = 'LOADING';			//starts loading of self swf first			trace("self?: " + mc.self);			if(mc.self == true && mc.mandatory == false)			{				if(_fProgress != null) mc.url.loaderInfo.addEventListener(ProgressEvent.PROGRESS, _fProgress);				mc.url.loaderInfo.addEventListener(ProgressEvent.PROGRESS,onLoadProgress);				if(_fComplete != null) mc.url.loaderInfo.addEventListener(Event.COMPLETE, _fComplete);				mc.url.loaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onLoadError);			}			else 			{				//items in aloadArray will be loaded in order				for (oIndex in loadArray)				{					loader = new CustomLoader();					var url = loadArray[oIndex].url;					var urlRequest = new URLRequest(url);							if(url is String)					{							loader.load(urlRequest);					}					else if(urlRequest is ByteArray)					{						loader.loadBytes(url);					}										if(mc.self != true)					{ addChild(loader); }					var a = loadArray[oIndex];					setListeners(a.fComplete,a.fProgress,a.fError);							totalAssets++;					trace("totalAssets:" + totalAssets);				}			}		}		public function setListeners(_fComplete,_fProgress,_fError)		{			loader.contentLoaderInfo.addEventListener(Event.INIT,onLoadStart);			loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS,onLoadProgress);						if(_fProgress != null) loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS,_fProgress);			loader.contentLoaderInfo.addEventListener(Event.COMPLETE,onLoadComplete);						if(_fComplete != null) loader.contentLoaderInfo.addEventListener(Event.COMPLETE,_fComplete);									if(_fError != null) loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,_fError);			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,onLoadError);		}				public function onLoadStart(e:Event):void		{			//trace("Loading started...");		}				//updates progress status and converts to load percentage		public function onLoadProgress(e:ProgressEvent)		{				if(loaderState != 'POST') //don't calculate percentage for passive loads			{				//if there is no totalBytes value, then just one has started loading				//so add one to the count of assets manually				if(totalBytes[e] == undefined)				{					totalOverAllBytes += e.bytesTotal;					totalAudit++;				}				// adding either the initial total or the difference of the last total sent				totalOverallBytesLoaded += (totalBytes[e] == undefined) ? e.bytesLoaded: e.bytesLoaded - Number(totalBytes[e]);								// adding the total bytes loaded				totalBytes[e] += e.bytesLoaded;								// creating the percentage				if(!mc)  //different calculation for all assets that aren't "self"				{					progressOutput = String(Math.floor((totalOverallBytesLoaded/totalOverAllBytes) * 100) * 2);				} else { //quick fix calculation for "self" or calling swf because totalBytes isn't avail					progressOutput = String(Math.floor((totalOverallBytesLoaded/totalOverAllBytes) * 100));				}								if(totalAudit == totalAssets)				{					//trace("mandatory loads are counted");				}			}		}				public function getPercent():String		{			return progressOutput;		}				public function onLoadComplete(e:Event)		{			//turn off listeners for mandatory loads			kill();			totalComplete++;			//start loading passive loads if they exist			if(passiveLoadArray.length > 0)			{				loadPassive();			} else if(totalComplete == totalAssets) 			{				allCompleteCallback();			}		}				public function loadPassive()		{			if(passiveLoadArray.length > 0 && loaderState != 'POST')			{				loaderState 	= 'POST';				totalAssets 	= 0;				totalAudit 		= 0;				totalComplete	= 0;								for(oIndex in passiveLoadArray)				{					loader = new CustomLoader();					var url = passiveLoadArray[oIndex].url;					var urlRequest = new URLRequest(url);					if(url is String)					{						loader.load(urlRequest);					}					else if(urlRequest is ByteArray)					{						loader.loadBytes(url);					}					var pA = passiveLoadArray[oIndex];					setListeners(pA.fComplete,pA.fProgress,pA.fError);					addChild(loader);					totalAssets++;									}			}			else if(totalComplete == totalAssets && loaderState == 'POST')			{				kill();				reset();				passiveLoadArray == null;				allCompleteCallback();			}		}				public function allCompleteCallback():void		{			dispatchEvent(new Event(LoaderDispatcher.ASSETLOADER_COMPLETE));		}				public function onLoadError(e:IOErrorEvent):void		{			trace('ERROR LOADING ASSET');			kill();			closeAll();		}				public function closeAll():void		{			loader.close();		}				public function kill():void		{			loader.contentLoaderInfo.removeEventListener(Event.INIT,onLoadStart);			loader.contentLoaderInfo.removeEventListener(ProgressEvent.PROGRESS,onLoadProgress);						if(_fProgress != null) loader.contentLoaderInfo.removeEventListener(ProgressEvent.PROGRESS,_fProgress);						loader.contentLoaderInfo.removeEventListener(ProgressEvent.PROGRESS,onLoadComplete);						if(_fComplete != null) loader.contentLoaderInfo.removeEventListener(ProgressEvent.PROGRESS,_fComplete);						loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR,onLoadError);						if(_fError != null) loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR,_fError);		}	}}